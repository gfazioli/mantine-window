import { InstallScript } from './components/InstallScript/InstallScript';
import * as demos from './demos';

## Installation

<InstallScript packages="@gfazioli/mantine-window" />

After installation import package styles at the root of your application:

```tsx
import '@gfazioli/mantine-window/styles.css';
```

You can import styles within a layer `@layer mantine-window` by importing `@gfazioli/mantine-window/styles.layer.css` file.

```tsx
import '@gfazioli/mantine-window/styles.layer.css';
```

## Usage

The `Window` component allows you to create draggable and resizable windows within your application. It provides a familiar desktop-like experience for users. You can customize the appearance and behavior of the windows using various props. Also, you can choose whether the window should be rendered within a portal or relative to its parent container using the `withinPortal` prop.

> **Note:**
>
> Usually, you would want to use the `Window` component within a portal to avoid layout issues. However, if you want the window to be constrained within a specific container, you can set the `withinPortal` prop to `false` and the container should have `position: relative` style.
>
> For example, in the demos below, the `Window` component is rendered relative to its parent container which has `position: relative` style.

<Demo data={demos.configurator} />

## Controlled

You can control the open and close state of the `Window` component using the `opened` and `onClose` props. This allows you to manage the visibility of the window programmatically.

<Demo data={demos.controlled} />

## Within Portal vs Container

The `withinPortal` prop controls how the window is positioned. When `withinPortal={true}` (default), the window uses fixed positioning relative to the viewport. When `withinPortal={false}`, it uses absolute positioning relative to its parent container.

**Fixed positioning (withinPortal=true):**

- Window stays in place when scrolling
- Positioned relative to the browser viewport
- Best for modals and overlays

**Absolute positioning (withinPortal=false):**

- Window is constrained within parent container
- Parent must have `position: relative`
- Window cannot be dragged or resized outside container boundaries
- Best for embedded UI components

<Demo data={demos.withinPortal} />

## Custom Position

You can set the initial position of the window using the `defaultPosition` prop. This is useful when you want the window to appear at a specific location on the screen.

<Demo data={demos.customPosition} />

## Custom Size

Set custom initial dimensions for the window using the `defaultSize` prop. This allows you to control the width and height of the window when it first appears.

<Demo data={demos.customSize} />

## Viewport-based Position

You can use viewport units (`vw` for horizontal, `vh` for vertical) to set responsive positions that adapt to the browser window size. Viewport units are always calculated relative to the browser viewport, regardless of the `withinPortal` setting.

> **Note:**
>
> When using viewport units (vw/vh), use `withinPortal={true}` (default) for consistent behavior.

<Demo data={demos.viewportPosition} />

## Percentage Position

Percentage units calculate position relative to the reference container. With `withinPortal={false}`, percentages are relative to the parent container. The parent container must have `position: relative` style.

<Demo data={demos.percentagePosition} />

## Viewport-based Size

Use viewport units (`vw` for width, `vh` for height) to create responsive window sizes that scale proportionally with the viewport. Viewport units are always calculated relative to the browser viewport.

> **Note:**
>
> When using viewport units (vw/vh), use `withinPortal={true}` (default) for consistent behavior.

<Demo data={demos.viewportSize} />

## Percentage Size

Percentage units for size work differently based on the `withinPortal` setting. With `withinPortal={false}`, percentages are calculated relative to the parent container dimensions.

<Demo data={demos.percentageSize} />

## Responsive Windows

Combine viewport units for both position and size to create fully responsive windows. You can mix different unit types (pixels, viewport units, percentages) to achieve the perfect balance of flexibility and control.

> **Understanding Unit References:**
>
> | Unit Type | Reference (withinPortal=true) | Reference (withinPortal=false) |
> | --------- | ----------------------------- | ------------------------------ |
> | `vw/vh`   | Viewport (browser window)     | Viewport (browser window)      |
> | `%`       | Viewport (browser window)     | Parent container               |
> | `px`      | Fixed pixels                  | Fixed pixels                   |

> **Best Practices:**
>
> - Use `vw/vh` with `withinPortal={true}` (default) for viewport-relative sizing
> - Use `%` with `withinPortal={false}` for container-relative sizing
> - Parent container must have `position: relative` when using `withinPortal={false}`

<Demo data={demos.responsiveWindow} />

## Min/Max Size Constraints

Control the minimum and maximum dimensions during resize operations using `minWidth`, `minHeight`, `maxWidth`, and `maxHeight` props. This prevents the window from becoming too small or too large.

<Demo data={demos.minMaxSize} />

## Viewport-based Constraints

You can use viewport units (`vw` for width, `vh` for height) to create responsive constraints that adapt to the browser window size. This is particularly useful for creating windows that scale proportionally with the viewport.

<Demo data={demos.viewportConstraints} />

## Mixed Unit Constraints

Mix different unit types for more flexible sizing. You can combine fixed pixel values with viewport units to create hybrid constraints that work best for your use case.

<Demo data={demos.mixedConstraints} />

## Drag Boundaries

Restrict the draggable area of the window using the `dragBounds` prop. This ensures the window stays within specific boundaries and cannot be dragged outside the defined area.

<Demo data={demos.dragBounds} />

## Viewport-based Drag Boundaries

Use viewport units (`vw` for width, `vh` for height) to create responsive drag boundaries that adapt to the browser window size. This is useful for ensuring windows stay within proportional boundaries regardless of screen size.

<Demo data={demos.viewportDragBounds} />

## Percentage Drag Boundaries

Define drag boundaries using percentage values relative to the viewport or container size. Percentages provide a flexible way to constrain window movement proportionally.

<Demo data={demos.percentageDragBounds} />

## Mixed Unit Drag Boundaries

Combine different unit types (pixels, viewport units, percentages) for drag boundaries to create sophisticated constraints that meet your specific requirements.

<Demo data={demos.mixedDragBounds} />

## Persistence

Enable state persistence to save the window's position and size in localStorage by setting `persistState={true}` (default is `true`). When enabled, the window will remember its position and size across page refreshes. Set `persistState={false}` to disable this behavior and always start at the default position and size.

<Demo data={demos.persistence} />

## Callbacks

Use `onPositionChange` and `onSizeChange` callbacks to respond to window movements and resize operations. These callbacks receive the current position or size as arguments.

<Demo data={demos.callbacks} />

## Centered Window

Create a centered, fixed window that cannot be moved or resized by combining `defaultPosition`, `defaultSize`, `resizable="none"`, and `draggable="none"` props.

<Demo data={demos.centered} />

## Multiple Windows

You can render multiple windows in the same container. Each window maintains its own z-index and can be brought to the front by clicking on it. Use unique `id` props to ensure proper state persistence.

<Demo data={demos.multiple} />

## Disable Collapsing

Prevent the window from being collapsed by setting `collapsable={false}`. This removes the collapse functionality, including the double-click handler on the header.

<Demo data={demos.noCollapsable} />

## Styles API

`Window` supports [Styles API](https://mantine.dev/styles/styles-api/), you can add styles to any inner element of the component with `classNames` prop. Follow [Styles API](https://mantine.dev/styles/styles-api/) documentation to learn more.

You can customize the appearance of the `Window` component using the Styles API. This allows you to modify styles for various parts of the component, such as keys, values, brackets, and more.

<Demo data={demos.stylesApi} />
